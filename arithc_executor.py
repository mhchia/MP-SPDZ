import json
import os
from pathlib import Path


CIRCUIT_NAME = 'arith_circuit_interpreter'
CIRCUIT_INTERPRETER_PATH = Path(f'Programs/Source/{CIRCUIT_NAME}.mpc')
CIRCUIT_INTERPRETER_PATH.parent.mkdir(parents=True, exist_ok=True)
CMD_RUN_INTERPRETER = f'Scripts/compile-run.py -E semi {CIRCUIT_NAME}'

# Actual arithmetic circuit to be executed by the MP-SPDZ interpreter above
# ARITH_CIRCUIT_NAME = 'arith_circuit_example'
# ARITH_CIRCUIT_NAME = 'circ'
# ARITH_CIRCUIT_NAME = 'nn_circuit_small'
ARITH_CIRCUIT_NAME = 'two_outputs'
ARITH_CIRCUIT_PATH = f"{ARITH_CIRCUIT_NAME}.txt"
# Config file defining a input is either a constant or should be read from which party
CONFIG_PATH = f'Configs/{ARITH_CIRCUIT_NAME}.json'
NODE_ID_TO_WIRE_INDEX_PATH = f"{ARITH_CIRCUIT_NAME}.node_id_to_wire_index.json"
WIRE_ID_FOR_INPUT_PATH = f"{ARITH_CIRCUIT_NAME}.wire_id_for_inputs.json"


def main():
    # TODO: CONFIG_PATH should be an argument to the script
    wire_id_for_inputs, input_from_which_party, constants = prepare_inputs_for_circuit(NODE_ID_TO_WIRE_INDEX_PATH, CONFIG_PATH)

    # TODO: ARITH_CIRCUIT_PATH should be an argument to the script
    # TODO: Translate arithc generated by circom-2-arithc with Nam's parser
    num_outputs = parse_arith_circuit(ARITH_CIRCUIT_PATH)
    # Generate MP-SPDZ circuit to interpret the  and write to file
    interpreter_code = generate_arith_circuit_interpreter(ARITH_CIRCUIT_PATH, wire_id_for_inputs, input_from_which_party, constants, num_outputs)
    with open(CIRCUIT_INTERPRETER_PATH, 'w') as f:
        f.write(interpreter_code)
    # Run the MP-SPDZ interpreter to interpret the arithmetic circuit
    os.system(CMD_RUN_INTERPRETER)


# FIXME: should map rid to input index
def generate_arith_circuit_interpreter(
    arith_circuit_path: str,
    wire_index_for_input: list[int],
    input_from_which_party: list[int | None],
    constants: dict[int, int],
    num_outputs: int,
):
    assert len([i for i in input_from_which_party if i is None]) == len(constants), "Number of constants should match number of None in input_from_which_party"

    # FIXME: should have a mapping from rid to input_from_which_party.
    # But, we can only input arrays? Should be able to input mapping i think
    # Temporary workaround is to have another input_at_wire. input_at_wire[i] indicates the actual wire index that the input is mapped to
    inputs_str_list = [
        f'sint.get_input_from({_input_from_party})' if _input_from_party is not None else f'cint({constants[input_index]})'
        for input_index, _input_from_party in enumerate(input_from_which_party)
    ]
    inputs_str = '[' + ', '.join(inputs_str_list) + ']'
    print_outputs_str_list = [f"outputs[{i}].reveal()" for i in range(num_outputs)]
    with open(WIRE_ID_FOR_INPUT_PATH, 'w') as f:
        json.dump(wire_index_for_input, f)
    print_outputs_str = '[' + ', '.join(print_outputs_str_list) + ']'
    circuit = f"""from circuit_arith import Circuit
circuit = Circuit('{arith_circuit_path}')
inputs = {inputs_str}
outputs = circuit(inputs)
print_ln('outputs=%s', {print_outputs_str})
"""
    print("!@# circuit=")
    print(circuit)
    return circuit


def prepare_inputs_for_circuit(node_id_to_wire_index_path: str, user_config_path: str):
    # {"339827882353457231733281877774418513": 1, "261273425065800872138523378011643318856": 0, "224358152556191904480812644829082501076": 2}
    with open(node_id_to_wire_index_path, 'r') as f:
        raw = json.load(f)
        node_id_to_wire_index = {
            int(k): int(v)
            for k, v in raw.items()
        }
    # [
    #     {
    #         "wire_id": 339827882353457231733281877774418513,
    #         "wire_name": "a",
    #         "is_const": false,
    #         "const_value": 0,
    #         "from_party": 0
    #     },
    #     ...
    # ]
    with open(user_config_path, 'r') as f:
        user_config = json.load(f)
    constants = {}
    input_from_which_party: list[int | None] = []
    wire_index_for_input: list[int] = []
    for wire in user_config:
        wire_id = int(wire['wire_id'])
        is_wire_const = wire['is_const']
        const_value = int(wire['const_value'])
        from_party = int(wire['from_party'])
        wire_index = node_id_to_wire_index[wire_id]

        wire_index_for_input.append(wire_index)
        if is_wire_const:
            constants[wire_id] = const_value
            input_from_which_party.append(None)
        else:
            input_from_which_party.append(from_party)

        # Sanity
        assert is_wire_const == (const_value != 0), "is_const should be True if and only if const_value is not 0"
    # # input_from_which_party should be like `[0, None, 1, None]` where None means the input is a constant
    # input_from_which_party: list[int | None] = config['input_from_which_party']
    # constants_raw: dict[str, int] = config['constants']
    # # constants should be like `{1: 10, 3: 5}` where the key is the index of the input and the value is the corresponding constant
    # constants = {int(k): int(v) for k, v in constants_raw.items()}
    # return input_from_which_party, constants
    return wire_index_for_input, input_from_which_party, constants




def parse_arith_circuit(arith_circuit_path: str):
    # Get the number of outputs from the arithmetic circuit
    # Number of outputs is the first element of the third line
    with open(arith_circuit_path, 'r') as f:
        f.readline()
        f.readline()
        num_outputs = int(f.readline().split()[0])
    return num_outputs


if __name__ == '__main__':
    main()
